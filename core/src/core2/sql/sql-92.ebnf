(*

5  Lexical elements



5.1  <SQL terminal character>

Function

Define the terminal symbols of the SQL language and the elements of
strings.

Format

*)

<SQL-special-character> ::=
       space
     | double-quote
     | percent
     | ampersand
     | quote
     | left-paren
     | right-paren
     | asterisk
     | plus-sign
     | comma
     | minus-sign
     | period
     | solidus
     | colon
     | semicolon
     | less-than-operator
     | equals-operator
     | greater-than-operator
     | question-mark
     | underscore
     | vertical-bar

space ::=  <' '> (* !! space character in character set in use *)

double-quote ::= <'"'>

percent ::= <'%'>

ampersand ::= <'&'>

quote ::= <'\''>

left-paren ::= <'('>

right-paren ::= <')'>

asterisk ::= <'*'>

plus-sign ::= <'+'>

comma ::= <','>

minus-sign ::= <'-'>

period ::= <'.'>

solidus ::= <'/'>

colon ::= <':'>

semicolon ::= <';'>

less-than-operator ::= <'<'>

equals-operator ::= <'='>

greater-than-operator ::= <'>'>

question-mark ::= <'?'>

left-bracket ::= <'['>

right-bracket ::= <']'>

underscore ::= <'_'>

vertical-bar ::= <'|'>

(*

5.2  <token> and <separator>

Function

Specify lexical units (tokens and separators) that participate in
SQL language.

Format

*)

regular-identifier ::= #"[a-zA-Z_]\w*"

delimited-identifier ::=
     <double-quote> delimited-identifier-body <double-quote>

delimited-identifier-body ::= #"([^\"]|\"\")*"

not-equals-operator ::= <'<>'>

greater-than-or-equals-operator ::= <'>='>

less-than-or-equals-operator ::= <'<='>

concatenation-operator ::= <'||'>

double-period ::= <'..'>

(*

5.3  <literal>

Function

Specify a non-null value.

Format

*)

literal ::=
       signed-numeric-literal
     | general-literal

unsigned-literal ::=
       unsigned-numeric-literal
     | general-literal

general-literal ::=
       character-string-literal
     | national-character-string-literal
     | bit-string-literal
     | hex-string-literal
     | datetime-literal
     | interval-literal

character-string-literal ::=
     [ introducer character-set-specification ]
     <quote> character-representation <quote>
       ( <quote> character-representation <quote> )*

introducer ::= underscore

character-representation ::= #"([^']|'')*"

national-character-string-literal ::=
     <'N'> <quote> character-representation <quote>
       ( <quote> character-representation <quote> )*

bit-string-literal ::=
     <'B'> <quote> #"[01]*" <quote>
       ( <quote> #"[01]*" <quote> )*

hex-string-literal ::=
     <'X'> <quote> #"[0-9a-fA-F]+" <quote>
       ( <quote> #"[0-9a-fA-F]+" <quote> )*

signed-numeric-literal ::=
     [ sign ] unsigned-numeric-literal

unsigned-numeric-literal ::=
       exact-numeric-literal
     | approximate-numeric-literal

exact-numeric-literal ::= #"\d*\.?\d+"

sign ::= plus-sign | minus-sign

approximate-numeric-literal ::= mantissa <'E'> exponent

mantissa ::= exact-numeric-literal

exponent ::= signed-integer

signed-integer ::= [ sign ] unsigned-integer

unsigned-integer ::= #"\d+"

datetime-literal ::=
       date-literal
     | time-literal
     | timestamp-literal

date-literal ::=
     <'DATE'> date-string

time-literal ::=
     <'TIME'> time-string

timestamp-literal ::=
     <'TIMESTAMP'> timestamp-string

date-string ::=
     <quote> date-value <quote>

time-string ::=
     <quote> time-value [ time-zone-interval ] <quote>

timestamp-string ::=
     <quote> date-value <space> time-value [ time-zone-interval ] <quote>

time-zone-interval ::=
     sign hours-value <colon> minutes-value

date-value ::=
     years-value <minus-sign> months-value <minus-sign> days-value

time-value ::=
     hours-value <colon> minutes-value <colon> seconds-value

interval-literal ::=
     <'INTERVAL'> [ sign ] interval-string interval-qualifier

interval-string ::=
     <quote> ( year-month-literal | day-time-literal )+ <quote>

year-month-literal ::=
       years-value
     | [ years-value <minus-sign> ] months-value

day-time-literal ::=
       day-time-interval
     | time-interval

day-time-interval ::=
     days-value
       [ <space> hours-value [ <colon> minutes-value [ <colon> seconds-value ] ] ]

time-interval ::=
       hours-value [ <colon> minutes-value [ <colon> seconds-value ] ]

     | minutes-value [ <colon> seconds-value ]
     | seconds-value

years-value ::= datetime-value

months-value ::= datetime-value

days-value ::= datetime-value

hours-value ::= datetime-value

minutes-value ::= datetime-value

seconds-value ::=
       seconds-integer-value [ <period> [ seconds-fraction ] ]

seconds-integer-value ::= unsigned-integer

seconds-fraction ::= unsigned-integer

datetime-value ::= unsigned-integer

(*

5.4  Names and identifiers

Function

Specify names.

Format

*)

identifier ::=
     [ introducer character-set-specification ] actual-identifier

actual-identifier ::=
       regular-identifier
     | delimited-identifier

table-name ::=
       qualified-name
     | qualified-local-table-name

qualified-local-table-name ::=
     <'MODULE'> period local-table-name

local-table-name ::= qualified-identifier

domain-name ::= qualified-name

schema-name ::=
     [ catalog-name period ] unqualified-schema-name

unqualified-schema-name ::= identifier

catalog-name ::= identifier

qualified-name ::=
     [ schema-name period ] qualified-identifier

qualified-identifier ::= identifier

column-name ::= identifier

correlation-name ::= identifier

parameter-name ::= colon identifier

collation-name ::= qualified-name

character-set-name ::= [ schema-name period ] identifier

translation-name ::= qualified-name

form-of-use-conversion-name ::= qualified-name

(*

6  Scalar expressions



6.1  <data type>

Function

Specify a data type.

Format

*)

data-type ::=
       character-string-type [ <'CHARACTER'> <'SET'> character-set-specification ]
     | national-character-string-type
     | bit-string-type
     | numeric-type
     | datetime-type
     | interval-type

character-string-type ::=
       <'CHARACTER'> [ <left-paren> length <right-paren> ]
     | <'CHAR'> [ <left-paren> length <right-paren> ]
     | <'CHARACTER'> <'VARYING'> <left-paren> length <right-paren>
     | <'CHAR'> <'VARYING'> <left-paren> length <right-paren>
     | <'VARCHAR'> <left-paren> length <right-paren>

national-character-string-type ::=
       <'NATIONAL'> <'CHARACTER'> [ <left-paren> length <right-paren> ]
     | <'NATIONAL'> <'CHAR'> [ <left-paren> length <right-paren> ]
     | <'NCHAR'> [ <left-paren> length <right-paren> ]
     | <'NATIONAL'> <'CHARACTER'> <'VARYING'> <left-paren> length <right-paren>
     | <'NATIONAL'> <'CHAR'> <'VARYING'> <left-paren> length <right-paren>
     | <'NCHAR'> <'VARYING'> <left-paren> length <right-paren>

bit-string-type ::=
       <'BIT'> [ <left-paren> length <right-paren> ]
     | <'BIT'> <'VARYING'> <left-paren> length <right-paren>

numeric-type ::=
       exact-numeric-type
     | approximate-numeric-type

exact-numeric-type ::=
       'NUMERIC' [ <left-paren> precision [ <comma> scale ] <right-paren> ]
     | 'DECIMAL' [ <left-paren> precision [ <comma> scale ] <right-paren> ]
     | 'DEC' [ <left-paren> precision [ <comma> scale ] <right-paren> ]
     | 'INTEGER'
     | 'INT'
     | 'SMALLINT'

approximate-numeric-type ::=
       'FLOAT' [ <left-paren> precision <right-paren> ]
     | 'REAL'
     | 'DOUBLE' 'PRECISION'

length ::= unsigned-integer

precision ::= unsigned-integer

scale ::= unsigned-integer

datetime-type ::=
       'DATE'
     | 'TIME' [ <left-paren> time-precision <right-paren> ] [ 'WITH' 'TIME' 'ZONE' ]
     | 'TIMESTAMP' [ <left-paren> timestamp-precision <right-paren> ] [ 'WITH' 'TIME' 'ZONE' ]

time-precision ::= time-fractional-seconds-precision

timestamp-precision ::= time-fractional-seconds-precision

time-fractional-seconds-precision ::= unsigned-integer

interval-type ::= <'INTERVAL'> interval-qualifier

(*

6.2  <value specification> and <target specification>

Function

Specify one or more values, parameters, or variables.

Format

*)

value-specification ::=
       literal
     | general-value-specification

unsigned-value-specification ::=
       unsigned-literal
     | general-value-specification

general-value-specification ::=
       parameter-specification
     | dynamic-parameter-specification
     | 'USER'
     | 'CURRENT_USER'
     | 'SESSION_USER'
     | 'SYSTEM_USER'
     | 'VALUE'

simple-value-specification ::=
       parameter-name
     | literal

target-specification ::=
       parameter-specification

simple-target-specification ::=
       parameter-name

parameter-specification ::=
     parameter-name [ indicator-parameter ]

indicator-parameter ::=
     [ <'INDICATOR'> ] parameter-name

dynamic-parameter-specification ::= question-mark

(*

6.3  <table reference>

Function

Reference a table.

Format

*)

table-reference ::=
       table-name [ [ <'AS'> ] correlation-name
           [ <left-paren> derived-column-list <right-paren> ] ]
     | derived-table [ <'AS'> ] correlation-name
           [ <left-paren> derived-column-list <right-paren> ]
     | joined-table

derived-table ::= table-subquery

derived-column-list ::= column-name-list

column-name-list ::=
     column-name ( comma column-name )*

(*

6.4  <column reference>

Function

Reference a column.

Format

*)

column-reference ::= [ qualifier period ] column-name

qualifier ::=
       table-name
     | correlation-name

(*

6.5  <set function specification>

Function

Specify a value derived by the application of a function to an
argument.

Format

*)

set-function-specification ::=
       'COUNT' <left-paren> asterisk <right-paren>
     | general-set-function

general-set-function ::=
       set-function-type
           left-paren [ set-quantifier ] value-expression right-paren


set-function-type ::=
     'AVG' | 'MAX' | 'MIN' | 'SUM' | 'COUNT'

set-quantifier ::= 'DISTINCT' | 'ALL'

(*

6.6  <numeric value function>

Function

Specify a function yielding a value of type numeric.

Format

*)

numeric-value-function ::=
       position-expression
     | extract-expression
     | length-expression

position-expression ::=
     <'POSITION'> <left-paren> character-value-expression
         <'IN'> character-value-expression <right-paren>

length-expression ::=
       char-length-expression
     | octet-length-expression
     | bit-length-expression

char-length-expression ::=
     <( 'CHAR_LENGTH' | 'CHARACTER_LENGTH' )>
         <left-paren> string-value-expression <right-paren>

octet-length-expression ::=
     <'OCTET_LENGTH'> <left-paren> string-value-expression <right-paren>

bit-length-expression ::=
     <'BIT_LENGTH'> <left-paren> string-value-expression <right-paren>

extract-expression ::=
     <'EXTRACT'> <left-paren> extract-field
         <'FROM'> extract-source <right-paren>

extract-field ::=
       datetime-field
     | time-zone-field

time-zone-field ::=
       'TIMEZONE_HOUR'
     | 'TIMEZONE_MINUTE'

extract-source ::=
       datetime-value-expression
     | interval-value-expression

(*

6.7  <string value function>

Function

Specify a function yielding a value of type character string or bit
string.

Format

*)

string-value-function ::=
       character-value-function
     | bit-value-function

character-value-function ::=
       character-substring-function
     | fold
     | form-of-use-conversion
     | character-translation
     | trim-function

character-substring-function ::=
     <'SUBSTRING'> <left-paren> character-value-expression <'FROM'> start-position
                 [ <'FOR'> string-length ] <right-paren>

fold ::= ( 'UPPER' | 'LOWER' ) <left-paren> character-value-expression <right-paren>


form-of-use-conversion ::=
     <'CONVERT'> <left-paren> character-value-expression
         <'USING'> form-of-use-conversion-name <right-paren>

character-translation ::=
     <'TRANSLATE'> <left-paren> character-value-expression
         <'USING'> translation-name <right-paren>

trim-function ::=
     <'TRIM'> <left-paren> trim-operands <right-paren>

trim-operands ::=
     [ [ trim-specification ] [ trim-character ] <'FROM'> ] trim-source


trim-source ::= character-value-expression

trim-specification ::=
       'LEADING'
     | 'TRAILING'
     | 'BOTH'

trim-character ::= character-value-expression

bit-value-function ::=
     bit-substring-function

bit-substring-function ::=
     <'SUBSTRING'> <left-paren> bit-value-expression <'FROM'> start-position
         [ <'FOR'> string-length ] <right-paren>

start-position ::= numeric-value-expression

string-length ::= numeric-value-expression

(*

6.8  <datetime value function>

Function

Specify a function yielding a value of type datetime.

Format

*)

datetime-value-function ::=
       current-date-value-function
     | current-time-value-function
     | current-timestamp-value-function

current-date-value-function ::= <'CURRENT_DATE'>

current-time-value-function ::=
       <'CURRENT_TIME'> [ <left-paren> time-precision <right-paren> ]

current-timestamp-value-function ::=
       <'CURRENT_TIMESTAMP'> [ <left-paren> timestamp-precision <right-paren> ]

(*

6.9  <case expression>

Function

Specify a conditional value.

Format

*)

case-expression ::=
       case-abbreviation
     | case-specification

case-abbreviation ::=
       <'NULLIF'> <left-paren> value-expression <comma>
             value-expression <right-paren>
     | <'COALESCE'> <left-paren> value-expression
             ( <comma> value-expression )+ <right-paren>

case-specification ::=
       simple-case
     | searched-case

simple-case ::=
     <'CASE'> case-operand
       simple-when-clause+
       [ else-clause ]
     <'END'>

searched-case ::=
     <'CASE'>
       searched-when-clause+
       [ else-clause ]
     <'END'>

simple-when-clause ::= <'WHEN'> when-operand <'THEN'> result

searched-when-clause ::= <'WHEN'> search-condition <'THEN'> result

else-clause ::= <'ELSE'> result

case-operand ::= value-expression

when-operand ::= value-expression

result ::= result-expression | 'NULL'

result-expression ::= value-expression

(*

6.10  <cast specification>

Function

Specify a data conversion.

Format

*)

cast-specification ::=
     <'CAST'> <left-paren> cast-operand <'AS'> cast-target <right-paren>

cast-operand ::=
       value-expression
     | 'NULL'

cast-target ::=
       domain-name
     | data-type

(*

6.11  <value expression>

Function

Specify a value.

Format

*)

value-expression ::=
       numeric-value-expression
     | string-value-expression
     | datetime-value-expression
     | interval-value-expression

value-expression-primary ::=
       unsigned-value-specification
     | column-reference
     | set-function-specification
     | scalar-subquery
     | case-expression
     | left-paren value-expression right-paren
     | cast-specification

(*

6.12  <numeric value expression>

Function

Specify a numeric value.

Format

*)

numeric-value-expression ::=
       term
     | numeric-value-expression plus-sign term
     | numeric-value-expression minus-sign term

term ::=
       factor
     | term asterisk factor
     | term solidus factor

factor ::=
     [ sign ] numeric-primary

numeric-primary ::=
       value-expression-primary
     | numeric-value-function

(*

6.13  <string value expression>

Function

Specify a character string value or a bit string value.

Format

*)

string-value-expression ::=
       character-value-expression
     | bit-value-expression

character-value-expression ::=
       concatenation
     | character-factor

concatenation ::=
     character-value-expression concatenation-operator
     character-factor

character-factor ::=
     character-primary [ collate-clause ]

character-primary ::=
       value-expression-primary
     | string-value-function

bit-value-expression ::=
       bit-concatenation
     | bit-factor

bit-concatenation ::=
     bit-value-expression concatenation-operator bit-factor

bit-factor ::= bit-primary

bit-primary ::=
       value-expression-primary
     | string-value-function

(*

6.14  <datetime value expression>

Function

Specify a datetime value.

Format

*)

datetime-value-expression ::=
       datetime-term
     | interval-value-expression plus-sign datetime-term
     | datetime-value-expression plus-sign interval-term
     | datetime-value-expression minus-sign interval-term

datetime-term ::=
       datetime-factor

datetime-factor ::=
       datetime-primary [ time-zone ]

datetime-primary ::=
       value-expression-primary
     | datetime-value-function

time-zone ::=
     <'AT'> time-zone-specifier

time-zone-specifier ::=
       'LOCAL'
     | 'TIME' 'ZONE' interval-value-expression

(*

6.15  <interval value expression>

Function

Specify an interval value.

Format

*)

interval-value-expression ::=
       interval-term
     | interval-value-expression-1 plus-sign interval-term-1
     | interval-value-expression-1 minus-sign interval-term-1
     | <left-paren> datetime-value-expression minus-sign
           datetime-term <right-paren> interval-qualifier

interval-term ::=
       interval-factor
     | interval-term-2 asterisk factor
     | interval-term-2 solidus factor
     | term asterisk interval-factor

interval-factor ::=
     [ sign ] interval-primary

interval-primary ::=
       value-expression-primary [ interval-qualifier ]

interval-value-expression-1 ::= interval-value-expression

interval-term-1 ::= interval-term

interval-term-2 ::= interval-term

(*

7  Query expressions



7.1  <row value constructor>

Function

Specify an ordered set of values to be constructed into a row or
partial row.

Format

*)

row-value-constructor ::=
       row-value-constructor-element
     | <left-paren> row-value-constructor-list <right-paren>
     | row-subquery

row-value-constructor-list ::=
     row-value-constructor-element
         ( <comma> row-value-constructor-element )*

row-value-constructor-element ::=
       value-expression
     | null-specification
     | default-specification

null-specification ::=
     <'NULL'>

default-specification ::=
     <'DEFAULT'>

(*

7.2  <table value constructor>

Function

Specify a set of <row value constructor>s to be constructed into a
table.

Format

*)

table-value-constructor ::=
     <'VALUES'> table-value-constructor-list

table-value-constructor-list ::=
     row-value-constructor ( <comma> row-value-constructor )*

(*

7.3  <table expression>

Function

Specify a table or a grouped table.

Format

*)

table-expression ::=
     from-clause
     [ where-clause ]
     [ group-by-clause ]
     [ having-clause ]

(*

7.4  <from clause>

Function

Specify a table derived from one or more named tables.

Format

*)

from-clause ::= <'FROM'> table-reference ( <comma> table-reference )*

(*

7.5  <joined table>

Function

Specify a table derived from a Cartesian product, inner or outer
join, or union join.

Format

*)

joined-table ::=
       cross-join
     | qualified-join
     | left-paren joined-table right-paren

cross-join ::=
     table-reference <'CROSS'> <'JOIN'> table-reference

qualified-join ::=
     table-reference [ 'NATURAL' ] [ join-type ] <'JOIN'>
       table-reference [ join-specification ]

join-specification ::=
       join-condition
     | named-columns-join

join-condition ::= <'ON'> search-condition

named-columns-join ::=
     <'USING'> <left-paren> join-column-list <right-paren>

join-type ::=
       'INNER'
     | outer-join-type [ 'OUTER' ]
     | 'UNION'

outer-join-type ::=
       'LEFT'
     | 'RIGHT'
     | 'FULL'

join-column-list ::= column-name-list

(*

7.6  <where clause>

Function

Specify a table derived by the application of a <search condition>
to the result of the preceding <from clause>.

Format

*)

where-clause ::= <'WHERE'> search-condition

(*

7.7  <group by clause>

Function

Specify a grouped table derived by the application of the <group by
clause> to the result of the previously specified clause.

Format

*)

group-by-clause ::=
     <'GROUP'> <'BY'> grouping-column-reference-list

grouping-column-reference-list ::=
     grouping-column-reference ( <comma> grouping-column-reference )*


grouping-column-reference ::=
     column-reference [ collate-clause ]

(*

7.8  <having clause>

Function

Specify a grouped table derived by the elimination of groups from
the result of the previously specified clause that do not meet the
<search condition>.

Format

*)

having-clause ::= <'HAVING'> search-condition

(*

7.9  <query specification>

Function

Specify a table derived from the result of a <table expression>.

Format

*)

query-specification ::=
     <'SELECT'> [ set-quantifier ] select-list table-expression

select-list ::=
       asterisk
     | select-sublist ( <comma> select-sublist )*

select-sublist ::=
       derived-column
     | qualifier <period> asterisk

derived-column ::= value-expression [ as-clause ]

as-clause ::= [ <'AS'> ] column-name

(*

7.10  <query expression>

Function

Specify a table.

Format

*)

query-expression ::=
       non-join-query-expression
     | joined-table

non-join-query-expression ::=
       non-join-query-term
     | query-expression 'UNION'  [ 'ALL' ] [ corresponding-spec ] query-term
     | query-expression 'EXCEPT' [ 'ALL' ] [ corresponding-spec ] query-term

query-term ::=
       non-join-query-term
     | joined-table

non-join-query-term ::=
       non-join-query-primary
     | query-term 'INTERSECT' [ 'ALL' ] [ corresponding-spec ] query-primary

query-primary ::=
       non-join-query-primary
     | joined-table

non-join-query-primary ::=
       simple-table
     | left-paren non-join-query-expression right-paren

simple-table ::=
       query-specification
     | table-value-constructor
     | explicit-table

explicit-table ::= <'TABLE'> table-name

corresponding-spec ::=
     <'CORRESPONDING'> [ <'BY'> <left-paren> corresponding-column-list <right-paren> ]

corresponding-column-list ::= column-name-list

(*

7.11  <scalar subquery>, <row subquery>, and <table subquery>

Function

Specify a scalar value, a row, or a table derived from a <query
expression>.

Format

*)

scalar-subquery ::= subquery

row-subquery ::= subquery

table-subquery ::= subquery

subquery ::= <left-paren> query-expression <right-paren>

(*

8  Predicates



8.1  <predicate>

Function

Specify a condition that can be evaluated to give a truth value of
true, false, or unknown.

Format

*)

predicate ::=
       comparison-predicate
     | between-predicate
     | in-predicate
     | like-predicate
     | null-predicate
     | quantified-comparison-predicate
     | exists-predicate
     | unique-predicate
     | match-predicate
     | overlaps-predicate

(*

8.2  <comparison predicate>

Function

Specify a comparison of two row values.

Format

*)

comparison-predicate ::=
     row-value-constructor comp-op row-value-constructor

comp-op ::=
       equals-operator
     | not-equals-operator
     | less-than-operator
     | greater-than-operator
     | less-than-or-equals-operator
     | greater-than-or-equals-operator

(*

8.3  <between predicate>

Function

Specify a range comparison.

Format

*)

between-predicate ::=
     row-value-constructor [ 'NOT' ] <'BETWEEN'>
       row-value-constructor <'AND'> row-value-constructor

(*

8.4  <in predicate>

Function

Specify a quantified comparison.

Format

*)

in-predicate ::=
     row-value-constructor
       [ 'NOT' ] <'IN'> in-predicate-value

in-predicate-value ::=
       table-subquery
     | <left-paren> in-value-list <right-paren>

in-value-list ::=
     value-expression ( <comma> value-expression )*

(*

8.5  <like predicate>

Function

Specify a pattern-match comparison.

Format

*)

like-predicate ::=
     match-value [ 'NOT' ] <'LIKE'> pattern
       [ <'ESCAPE'> escape-character ]

match-value ::= character-value-expression

pattern ::= character-value-expression

escape-character ::= character-value-expression

(*

8.6  <null predicate>

Function

Specify a test for a null value.

Format

*)

null-predicate ::= row-value-constructor <'IS'> [ 'NOT' ] <'NULL'>

(*

8.7  <quantified comparison predicate>

Function

Specify a quantified comparison.

Format

*)

quantified-comparison-predicate ::=
     row-value-constructor comp-op quantifier table-subquery

quantifier ::= all | some

all ::= <'ALL'>

some ::= <'SOME'> | <'ANY'>

(*

8.8  <exists predicate>

Function

Specify a test for a non-empty set.

Format

*)

exists-predicate ::= <'EXISTS'> table-subquery

(*

8.9  <unique predicate>

Function

Specify a test for the absence of duplicate rows.

Format

*)

unique-predicate ::= <'UNIQUE'> table-subquery

(*

8.10  <match predicate>

Function

Specify a test for matching rows.

Format

*)

match-predicate ::=
     row-value-constructor <'MATCH'> [ 'UNIQUE' ] [ 'PARTIAL' | 'FULL' ] table-subquery

(*

8.11  <overlaps predicate>

Function

Specify a test for an overlap between two events.

Format

*)

overlaps-predicate ::=
     row-value-constructor-1 <'OVERLAPS'> row-value-constructor-2

row-value-constructor-1 ::= row-value-constructor

row-value-constructor-2 ::= row-value-constructor

(*

8.12  <search condition>

Function

Specify a condition that has the truth value true, false, or
unknown, depending on the result of applying boolean operators
to specified conditions.

Format

*)

search-condition ::=
       boolean-term
     | search-condition 'OR' boolean-term

boolean-term ::=
       boolean-factor
     | boolean-term 'AND' boolean-factor

boolean-factor ::=
     [ 'NOT' ] boolean-test

boolean-test ::=
     boolean-primary [ <'IS'> [ 'NOT' ] truth-value ]

truth-value ::=
       'TRUE'
     | 'FALSE'
     | 'UNKNOWN'

boolean-primary ::=
       predicate
     | <left-paren> search-condition <right-paren>

(*

10  Additional common elements



10.1  <interval qualifier>

Function

Specify the precision of an interval data type.

Format

*)

interval-qualifier ::=
       start-field <'TO'> end-field
     | single-datetime-field

start-field ::=
     non-second-datetime-field
         [ <left-paren> interval-leading-field-precision <right-paren> ]

end-field ::=
       non-second-datetime-field
     | 'SECOND' [ <left-paren> interval-fractional-seconds-precision <right-paren> ]

single-datetime-field ::=
       non-second-datetime-field
           [ <left-paren> interval-leading-field-precision <right-paren> ]
     | 'SECOND' [ <left-paren> interval-leading-field-precision
           [ <comma> interval-fractional-seconds-precision ] <right-paren> ]

datetime-field ::=
       non-second-datetime-field
     | 'SECOND'

non-second-datetime-field ::= 'YEAR' | 'MONTH' | 'DAY' | 'HOUR' | 'MINUTE'

interval-fractional-seconds-precision ::= unsigned-integer

interval-leading-field-precision ::= unsigned-integer

(*

10.4  <character set specification>

Function

Identify a character set.

Format

*)

character-set-specification ::=
       standard-character-repertoire-name
     | implementation-defined-character-repertoire-name
     | user-defined-character-repertoire-name
     | standard-universal-character-form-of-use-name
     | implementation-defined-universal-character-form-of-use-name

standard-character-repertoire-name ::= character-set-name

implementation-defined-character-repertoire-name ::= character-set-name

user-defined-character-repertoire-name ::= character-set-name

standard-universal-character-form-of-use-name ::=
     character-set-name

implementation-defined-universal-character-form-of-use-name ::=
     character-set-name

(*

10.5  <collate clause>

Function

Specify a collating sequence.

Format

*)

collate-clause ::= <'COLLATE'> collation-name
