= XTDB Core2 Technical Vision

== Table of Contents

1. Why?
2. What?
3. The Anchors
4. The Pillars
5. User Experience
6. Essence


== Why?

The timing of Core2 is due to the confluence of a number of factors.

=== Cloud

* Cloud services are the infrastructure default for new businesses.
* Serverless scalability (including the ability to scale _down_) matters more and more in a fast-paced and unpredictable world economy.
* (Good) developers are expensive.
* Automation means more than doing yesterday's manual tasks in a programmatic fashion tomorrow.
* Clarity and simplicity are forms of automation.

=== Immutable Data

* Immutable data provides clarity to both developers and businesses but only within the past decade has it become affordable for normal (i.e. not Google) businesses to hold onto all the data they've ever had.
* Storing an ever-growing set of historical data is possible with Object Storage, like Amazon S3.
* Handling an ever-growing set of historical data is a hassle -- dealing with this is a gap.

=== Time

* Immutable data creates a read-only timeline.
* A read-write timeline is called "bitemporal" ... although most developers and businesses do not initially care about writing data into the past and the future, the power and convenience of doing so is underestimated since software systems today must create custom features to allow such behaviour. This is another form of "automated simplicity" -- think Garbage Collectors.
* Bitemporal data requires dynamic structures / shapes / schema.
** These structures must not penetrate the boundary of a _type_. A strict set of types avoids accidental complexity.

=== Society and Culture

* The past 20 years have brought dynamic typing and functional programming into the mainstream. Both are necessary for an immutable database.
** _Dynamic schema_ is a technical constraint. It is necessary to support a read-write (bitemporal) timeline. It's also a cultural constraint. The real world is messy and the database should support the data first and the shape/schema second.
** _Functional programming_ is a social constraint. It is necessary that society (software developers, data scientists, etc.) appreciate the value of immutability and repeatability. If they don't, immutable records will be seen as a luxury.

=== Legacy

* No database product lives in a vacuum -- predicting which legacy will survive the next 50 years matters.
* Columnar storage is increasingly the norm, even outside of purely analytical applications.
* The 21st Century brings with it an entirely new world of privacy concerns. Although laws like GDPR and PIPEDA are (arguably) a bare minimum, their existence acts as a forcing function on data tools. Thanks in no small part to GDPR, _erasure_ is non-optional in a modern database.
* Computer languages are hard to get right. Although there are many attractive and modern alternatives to SQL, the SQL family of languages absolutely dominate the landscape of data products in 2022. This isn't going to change any time soon and, thankfully, SQL has a specification.


== What?

That all sounds like a lot.
In some ways, it is.
There is a lot of work required to make Core2 a reality.

The timeliness of technical details, mentioned above, act as pillars to this central ideal.
Although pillars may shift based on product/market fit, it's unlikely any one would be removed or replaced.
If we imagine each pillar as an actual physical column, it will have "faces" which an observer can see by walking around the pillar and looking at it from different angles.

A sketch of the pillars ("features") and ideas which underpin them can be seen here:

image::img/vision-features-and-ideas.svg[Vision: Features and Ideas SVG]

Prior to the pillars, however, there are _anchors_.


== The Anchors

Individually, the anchors represent "hard" constraints on the architecture of XTDB Core2.
Together, the space between these anchors represents the flexibility the architecture will need to embrace to support the pillars which follow.

=== SQL Specification

The SQL spec can be used to resolve potentially endless language-design discussions, but it also acts as a voice of (experiential) reason.
It wasn't designed in a vacuum and, although many of its qualities may be unattractive due to its lengthy history, it is common ground for all SQL databases.

For XTDB Core2, the SQL spec acts as a starting point and a home base.
Start with the SQL spec and deviate / append as necessary, preferably with debate in an ADR.
It should not be treated as a backstop.

=== Apache Arrow

The Arrow ecosystem is constantly evolving and it affords a number of advantages.
The rich Arrow type system removes ambiguity around which types Core2 supports.
XTDB Core2's intended future as an HTAP database means data science is an important user base -- playing nicely means a lot.
Core2's usage of Arrow shouldn't ever break promises that a regular Arrow user might come to expect.


== The Pillars

=== Immutable (Temporal)

* transactions require a consistent source of time
* consistent: reads of historical data are always repeatable -- this is Core2's commitment to safety
* deterministic: back doors, modularity, and customization should be actively discouraged (if not forbidden) by the design

=== Schemaless / Nested

* target "semi-structured" (realistically, some commonality will exist between rows/documents written in any given time window)
* joins over nested data should not feel "special"
* semi-structured data is first class; JSON columns are not directly supported because they are unnecessary

==== Dynamic

* schema "migration" is automatic, from the perspective of the database
* schema is tracked in the database, but implicitly ... every record may have its own schema (although this is unlikely)
* schema is tracked in userland, explicitly ... rather than reconciling program behaviour and schema migrations across a program's timeline (git history, usually), program behaviour and record schema are ambigrammatic. The schema may also be subject to assertion.

=== Columnar / HTAP

* build to support (slow) arbitrary OLAP queries
* reduce need for ETL
* concede / expect that OLTP frontends are favoured by most users

=== SQL

==== Specification

* treat the specification as a foundation
** Postgres feels like a spec, but prefer the real spec to Postgres
* begin with SQL:2011
* look to SQL:2016 (JSON) and SQL:2023 (PGQ, when it exists) for inspiration

=== Bitemporal / SQL:2011

* this is a "high bar" set early in Core2's development
* working backward from bitemporality (toward a simple immutable experience) means never losing sight of the goal
* bitemporality should be (optionally) invisible to users -- most users do not want it

=== Separation of Storage and Compute

* object storage like S3 and Azure blobs are unlimited, making object storage a very sensible solution to database contents with unbounded growth
* outsourcing unbounded growth to commodity object storage is another form of automation
* object storage is a natural extension of the standard size/speed hierarchy: cache, RAM, SSDs, disk, etc.
* caching and indexing of data over object storage is novel -- many answers to which indexing strategies (at each layer) XTDB Core2 will ultimately choose must be discovered iteratively
* a sensible, initial approach is to simply duplicate all storage on each compute node
* later approaches are discussed in https://xtdb.com/pdfs/Light_And_Adaptive_Indexing_for_Immutable_Databases_v7.pdf

=== Erasure (n√©e "Eviction")

* absolute _lowest_ performance priority
** erasure should be respected as it is transacted, to future reads, but can take a long time (on the order of minutes, hours) to actually delete data, since it is only intended for compliance purposes


== User Experience

=== Infra ("DBaaS")

* multi-tenant, "scale-to-zero" Kubernetes

=== Drivers / Clients / APIs

The XTDB SQL:2011 dialect _is_ the UI.

There are multiple ways to speak this SQL dialect over the wire.
There is no One True Wire Protocol ... yet.
In time, it's likely that one (or maybe two) clients/drivers will emerge as the product's preferred choice.

Each tool preferably behaves as an existing user would expect (or as close as possible).
"Don't make me think."
The reason two tools may be necessary is that row-oriented and column-oriented interfaces are both important to XTDB.

* `pgwire` -- today. a necessary evil (OLTP-shaped txns, json out)
* `FlightSQL` -- hopefully? XTDB team needs to coordinate with Arrow committers
* `HTTP` -- eventually. doing this right requires a lot of careful thought.
* `Bespoke "Native" Drivers` -- hopefully to be avoided? (novel client APIs are antithetical.) may build on top of Flight SQL or on top of HTTP. could use ADBC?

Be prepared not to have all the answers.
A good user experience is about _iteration_ on the sharp edges ... these will all feel somewhat broken at first.


== Essence

The essence of Core2 is a _standards-compliant immutable database_.
